# 6. 키워드 예제

<aside>
🔐 Q1. API란 무엇인가?

</aside>

API는 프로그램들이 상호 작용하는 것을 도와주는 매개체이다. 즉, 서버와 데이터베이스에 대한 출입구 역할을 한다. 데이터베이스에 아무나 접근하지 못하도록 API를 통해 허용된 사람만 접근할 수 있도록한다. 또 API는 모든 접속을 표준화하여, 기계/ 운영체제 등과 상관없이 누구나 동일한 액세스를 얻게 해준다.
API는 다음과 같은 유형으로 나뉜다.
private : 내부 API로, 회사 개발자가 자체 제품과 서비스를 개선하기 위해 내부적으로 발행하여 외부에 노출되지 않는다.
public : 개방형 API로, 누구나 제한 없이 API를 사용할 수 있다.
partner : 기업이 데이터 공유에 동의하는 특정인만 사용할 수 있다. 비즈니스 관계 또는 파트너 회사 간에 소프트웨어를 통합하기 위해 사용한다.

<aside>
🔐 Q2. Client와 Sever란 무엇인가?

</aside>

클라이언트와 서버는 두 개의 컴퓨터 프로그램 사이에 정보를 주고받는 관계로 클라이언트는 서비스를 요청하는 프로그램이고 서버는 그 요청에 응답해주는 프로그램이다.
예를 들어, 택배 배송 상황을 조회하려고 하는 경우, 먼저 자신의 PC에 있는 클라이언트 프로그램이 택배 회사에 위치한 서버에 그 요구 사항을 전송하게 되고, 거래 서버는 다시 배송 내역을 검색해주는 일을 하는 데이터베이스 서버에 그 요구 사항을 보내게 된다. 데이터베이스 서버가 배송 내역을 검색하여 그 내용을 서버에 보내면, 서버는 다시 그 내용을 택배 배송 상황을 요구한 PC의 클라이언트 프로그램으로 보냄으로써, 최종적으로 배송 상황이 화면(클라이언트)에 나타나게 된다.

<aside>
🔐 Q3. WAS란 무엇인가? Web Server와 차이점은 무엇인가?

</aside>

먼저 DBMS(Database Management System)와 MiddleWare부터 아는 것이 좋다. DBMS는 여러 사용자들이 db의 데이터에 접근하게 해주는 소프트웨어(MySQL, Oracle 등)이다. 이러한 DBMS에 직접 접근하여 이용하게 되면 클라이언트에 로직이 많아져야 하고, 로직이 변경되면 다시 배포해야 하기 때문에 보안 상의 문제가 생길 수 있다. 그렇기 때문에 클라이언트와 db서버 사이에 MiddleWare서버를 만들게 되었다. 클라이언트는 단순히 요청을 MiddleWare서버에 보내고, MiddleWare서버에서 대부분의 로직을 수행하며 데이터가 필요하면 DBMS에 데이터를 요청한다. 그렇게 만들어진 로직의 결과를 클라이언트에게 전달하면, 클라이언트가 그 결과를 화면에 보여준다.

이러한 미들웨어는 크게 Webserver와 WAS(Web Application Server)로 나뉜다.
웹서버는 하드웨어로 봤을때, 웹서버가 설치된 컴퓨터를 의미하고, 소프트웨어로 봤을땐 웹브라우저(클라이언트)의 http요청을 받아 정적인 컨텐츠(html/jpeg/css등)를 제공하는 프로그램을 의미한다. 서버는 정적인 컨텐츠는 WAS를 거치지 않고 바로 제공할 수 있다. 하지만 동적인 컨텐츠는 WAS에 요청을 보내고, WAS가 처리한 결과물을 클라이언트에게 보낸다. WAS는 여러 로직의 처리나 DB의 조회를 요구하는 동적인 컨텐츠 제공을 위해 만들어진 서버이다.웹 컨테이너(Web Container)나 서블릿 컨테이너(SErvlet Container)라고 불리며, JSP와 Servlet구동환경을 제공한다. 여러 개의 트랜잭션을 관리하고, 업무를 처리하는 비즈니스 로직을 수행한다.

그렇다면 왜 웹서버와 WAS를 나눠서 사용할까? 만약 정적 컨텐츠 요청까지 WAS가 처리하면 부하가 커지게 되고, 동적 컨텐츠의 처리까지 지연되어 수행 속도가 느려진다. 따라서 WAS를 통해 요청에 맞는 데이터를 DB에서 가져와서 비즈니스 로직에 맞게 결과를 만들어서 제공하면 자원을 효율적으로 사용할 수 있다. 또 SSL(암호화 기반 인터넷 보안 프로토콜)에 대한 암복호화 처리에 웹서버를 사용하여 보안 수준을 높일 수 있다. 그리고 fail over(장애 극복), fail back 처리를 할떄, 특히 대용량 웹 어플리케이션(여러 개의 서버 사용)은 웹서버와 WAS를 분리하여 무중단 운영을 위한 장애 극복에 쉽게 대응할 수 있다.(웹서버에서 오류가 난 WAS를 사용 못하게 만들고 WAS의 오류를 처리가능) 그래서 웹서버를 WAS 앞에 두고 Web Server에 플러그인으로 필요한 WAS를 설정하면 분산 처리를 할 수있다.

<aside>
🔐 Q4. HTTP 프로토콜이란 무엇인가?

</aside>

HTTP (Hyper Text Transfer Protocol)란 데이터를 주고 받기 위한 프로토콜로, 서버/클라이언트 모델을 따른다. HTTP는 상태 정보를 저장하지 않는 Stateless의 성질, 클라이언트의 요청에 맞는 응답을 보낸 후 연결을 끊는 Connectionless의 성질을 지닌다

장점:

- 통신 간의 연결 상태 처리나 상태 정보를 관리할 필요가 없어 서버 디자인이 간단하다.
- 각각의 HTTP 요청에 독립적으로 응답만 보내주면 OK

단점:

- 이전 통신의 정보를 모르기 때문에 매번 인증이 필요하다.
- 쿠키 및 세션을 이용, 인증 문제를 해결한다

<aside>
🔐 Q5. Restful API는 무엇인가?

</aside>

HTTP 프로토콜을 이용, URI를 통해 자원을 정의하고 CRUD한 http 메소드(get, post, put, delete)를

사용 행위를 결정한다. REST API는 HTTP의 메소드, URI로 이루어진 API 서버이므로, 필요한 것은 요청과 응답 이렇게 2가지가 존재하고, 어떠한 요청에 필요한 데이터와 그 결과 모델을 구성해야 한다.

- • 자원(Resource) - URI
- • 행위(Verb 또는 Action) - HTTP Method
- • 표현(Representations) - HTTP Message Body

REST API의 제약 조건

1. Client - Server (클라이언트 - 서버 형태)클라이언트 서버 형태의 원칙은 관심사의 명확한 분리를 말하며, 이를 지킴으로써 서버와 클라이언트의 역할을 분명히 함과 동시에 서버의 구성요소가 단순화되고 확장성이 향상되어, 여러 플랫폼을 지원할 수 있게 된다.
2. Stateless (무상태성)무상태성 원칙은 서버에 클라이언트의 상태 정보를 일절 저장하지 않음을 이야기 한다. 서버는 단순히 들어오는 요청만을 처리하여 구현을 단순화 하되, 클라이언트의 모든 요청은 서버가 요청을 알아듣는 데 필요한 모든 정보를 알고 있어야 한다. 이를 테면, 어떤 메소드를 요청했는지, 여기에 필요한 정보는 무엇인지 등을 이야기 한다.
3. Stateless (무상태성)무상태성 원칙은 서버에 클라이언트의 상태 정보를 일절 저장하지 않음을 이야기 한다. 서버는 단순히 들어오는 요청만을 처리하여 구현을 단순화 하되, 클라이언트의 모든 요청은 서버가 요청을 알아듣는 데 필요한 모든 정보를 알고 있어야 한다. 이를 테면, 어떤 메소드를 요청했는지, 여기에 필요한 정보는 무엇인지 등을 이야기 한다.
4. Uniform Interface (인터페이스 일관성)인터페이스 일관성 원칙은 URI를 가능한 지정된 리소스에 균일하고, 통일된 인터페이스를 제공해야 하는 원칙으로 아케텍처를 단순하게 분리하여 확장이 쉽도록 구현해야 한다는 원칙이다. 대표적으로는 각 Entity 별로 자원을 식별하는 방법, 혹은 HATEOAS를 이용하는 방법을 이야기 한다. HATEOAS란, 클라이언트에 응답하는 형식을 단순히 결과 데이터만 제공해주는 것이 아닌 URI를 함께 제공해야 한다는 원칙을 말한다.
5. 계층화 시스템 원칙은 애플리케이션 서버가 중계 서버(Proxy, Gateway)나 로드 밸런싱, 공유 캐시 등을 이용하여 확장성 있는 시스템을 구현해야 한다는 원칙이다
6. Code-On-Demand (코드 온 디맨드)코드 온 디맨드의 원칙은 반드시 지켜야 할 필수 원칙은 아니다. 이 원칙은 클라이언트가 서버에서 JavaApplet, Javascript 실행 코드를 전달 받아 기능을 일시적으로 확장할 수 있어야 한다는 원칙이다.

# DIY Section

<aside>
🔑 Q1. Git의 Branch와 merge는 무엇인가?

</aside>

브랜치(Branch)는 각 인원이 한 곳에 작업하는게 아니라 나뭇가지가 뻗어나오듯 다른 공간에 기능에 맞춰 작업할 수 있게 해준다. 예를 들어 fruits라는 프로젝트를 진행하고 한 명은 apple, 다른 한명은 banana라는 기능을 작업을 한다고 했을 때, 둘다 fruits라는 곳에 한번에 넣는 것이 아니라 apple은 사과 브랜치에서, banana는 바나나 브랜치에서 각각 작업을 하고, 나중에 메인 브랜치인 fruits에 합쳐주면 된다.
단, 중간 중간 작업 내역을 각 브랜치에 커밋해주는 것이 어떻게 진행되는지 파악하기에 좋다. 그리고 서로가 작업한 커밋 내역을 틈틈히 로컬 레포에 반영해 주어야 충돌을 줄일 수 있다. 각 브랜치는 작업이 끝나고 메인 브랜치에 합친 후 사용한 브랜치를 삭제해 그때그때 정리해야 나중에 헷갈리지 않는다. 또 작업할 브랜치로 바꾸는 것을 체크아웃(checkout)이라고 하며, 체크아웃된 브랜치에만 커밋이 반영된다.

머지(Merge)는 병합이라는 뜻으로 각 브랜치에서 작업한 것을 합치는 것을 의미한다. 특정 브랜치의 커밋내역을 다른 브랜치의 커밋내역에 모두 반영해준다. 실제 프로젝트에서는 작업 내역을 모두 합칠 기준 브랜치를 정해두고 작업한다. 각 브랜치를 머지하면 머지한 시간순으로 정렬하여 내역을 보여주기 때문에 각 내용을 합친 과정을 쉽게 알 수 있다. 머지하는 과정에서 충돌이 난다면 어떤 부분이 충돌(기존 내용/신규내용)했는지 알려주기 때문에, 당황하지 않고 충돌한 내역을 잘 수정하여 반영해주면 된다. 브랜치와 머지를 잘 활용하면 다른 사람들과 협업할 때, 좀 더 편리한 환경에서 작업할 수 있을것이다.

<aside>
🔑 Q2. AWS의 S3와 IAM의 특징은 무엇인가?

</aside>

AWS의 S3(Amazon Simple Storage Service)는 확장성, 데이터 가용성, 보안 및 성능을 제공하는 객체 스토리지 서비스이다. 모든 규모와 업종의 고객은 S3를 사용하여 데이터 레이크, 웹 사이트, 모바일 애플리케이션, 백업 및 복원, 아카이브, 엔터프라이즈 애플리케이션, IoT 디바이스, 빅 데이터 분석 등 다양한 사용 사례에서 원하는 양의 데이터를 저장하고 보호할 수 있습니다. S3는 특정 비즈니스, 조직 및 규정 준수 요구 사항에 맞게 데이터에 대한 액세스를 최적화, 구조화 및 구성할 수 있는 관리 기능을 제공한다.
S3의 특징으로는 많은 사용자가 접속을 해도 이를 감당하기 위한 작업을 하지 않아도 되고, 저장할 수 있는 파일 수의 제한이 없다. 또 최소 1바이트에서 최대 5TB의 데이터를 저장할 수 있고, 파일에 인증을 붙여서 무단으로 엑세스 하지 못하도록 할 수 있다. 그리고 HTTP와 BitTorrent 프로토콜을 지원해주고, REST, SOAP 인터페이스를 제공한다. 만약에 데이터를 여러 시설에서 중복으로 저장해 데이터의 손실이 발생하면 자동으로 복원해준다. 정보의 중요도에 따라서 보호 수준을 나눌 수 있다.

AWS IAM(Identity and Access Management)은 AWS 리소스에 대한 액세스를 안전하게 제어할 수 있는 웹 서비스로, 리소스를 사용할 때 누가, 무엇을, 어떻게 할 것인지에 대해 인증과 인가를 제어한다.
AWS에 어떠한 요청을 보낼 때 인증을 위한 자격 증명도 함께 보낸다. AWS는 해당 요청을 처리하기 전에 우선 자격 증명을 IAM에 보낸다. 그리고 IAM에서는 해당 자격 증명을 보고 해당 유저가 인증된 유저인지 확인하고, 인증된 유저면 해당 서비스와 서비스의 기능을 이용 권한이 있는지 등을 판별한 뒤 문제가 없다면 서비스 이용을 허용한다. AWS 계정을 생성할 때 루트 유저가 기본 생성되고 모든 권한을 가진다. 하지만 루트 유저를 이용하면 보안, 운영 면으로 좋지 않으므로, 일반적으로 IAM의 유저나 역할을 이용하여 AWS를 이용한다.
IAM에서 관리하는 리소스는 사용자(users), 그룹(groups), 역할(roles), 정책(policy)으로 구성된다. 정책에는 어떠한 권한에 대한 상세한 설정을 하고, 이 정책의 역할을 연결하고, 역할은 사용자나 AWS 리소스에 연결되어 해당 리소스나 유저의 권한을 설정하게 된다. 사용자는 인증을 위한 리소스로,
사용자를 만든 후에는 관리 콘솔에 로그인하기 위한 비밀번호와 자격 증명(액세스 키 ID, 비밀 액세스 키)을 생성할 수 있다. 그룹은 사용자 또는 역할과 달리 자격 증명이 없고, 인가를 담당하는 정책을 여러 사용자에게 효율적으로 배포하기 위한 틀이다.

<aside>
🔑 Q3. CORS(교차 출처 리소스 공유)에 대해 설명해주세요.

</aside>

CORS란 도메인이 서로 다른 2개의 사이트가 데이터를 주고 받을 때 발생하는 문제이다.

예를 들어 [a.com](http://a.com) ↔ b.com으로 데이터를 주고 받을 시 따로 설정하지 않으면 CORS 에러가 발생한다

따라서 다른 서버의 자원을 불러오기 위해서는 그 출처에서 CORS에 대한 내용을 Response의 헤더에 추가해주어야 한다

```
Access-Control-Allow-Orgin : 요청을 보내는 페이지의 출처 [ *, 도메인 ]
Access-Control-Allow-Methods : 요청을 허용하는 메소드. Default : GET, POST
Access-Control-Max-Age : 클라이언트에서 preflight 요청 (서버의 응답 가능여부에 대한 확인) 결과를 저장할 시간
Access-Control-Allow-Headers : 요청을 허용하는 헤더
```

<aside>
🔑 Q4.  MultipartFile과 File의 차이점은 무엇인가?

</aside>

멀티 파트(Multipart)는 웹 클라이언트가 요청을 보낼 때, HTTP 프로토콜의 바디 부분에 데이터를 여러 부분으로 나눠서 보내는 것이다. 웹 클라이언트가 서버에게 파일을 업로드할 때, http 프로토콜의 바디 부분에 파일 정보를 담아서 전송을 하는데, 파일을 한번에 여러 개 전송을 하면 body 부분에 파일이 여러 개의 부분으로 연결되어 전송됩니다.

멀티 파트 리졸버(MultipartResolver)의 경우 사용자의 파일 업로드 요청에 대한 처리를 하는 인터페이스다. 멀티 파트 리졸버의 경우 개발자가 별도의 Bean을 등록하지 않는 다고 해도 별도로 Spring에서 등록해 주지 않는다. 하지만 Spring Boot를 사용한다면 기본 구현체가 등록이 된다. springMVC에서는 파일 업로드 처리 시 DispatcherServlet에서 사용할 멀티 파트 리졸버의 Bean을 등록을 해주어야 한다.

멀티 파트 파일(MultipartFile)은 사용자가 업로드한 File을 핸들러에서 손쉽게 다룰 수 있게 도와주는 매개변수 중 하나이다. 매개변수를 사용하기 위해서는 멀티 파트 리졸버(MultipartResolver) Bean이 등록되어 있어야 한다. 스프링 부트에서는 자동 등록을 지원하지만, 스프링MVC에서 기본으로 등록해주지 않는다. 멀티 파트 파일 인터페이스는 스프링에서 업로드 한 파일을 표현할 때 사용되는 인터페이스이고, 이것을 이용해서 업로드한 파일의 이름, 실제 데이터, 파일 크기 등을 구할 수 있다.

파일(File) 클래스는 기본적이면서도 가장 많이 사용되는 입출력 대상이기 때문에 중요하다. 자바에서는 파일 클래스를 통해서 파일과 디렉토리를 다룰 수 있도록 하고 있다. 그래서 파일 인스턴스는 파일 일 수도 있고 디렉토리일 수도 있다.
