CORS(Cross Origin Resource Sharing)는 직역하면 교차 출처 리소스 공유로 CORS 정책이다. 도메인 및 포트가 다른 서버로 클라이언트가 
요청했을 때 브라우저가 보안상의 이유로 API를 차단하는것이다. CORS라는 방어막이 존재하기 때문에 여러 곳에서 가져오는 리소스가 
안전하다는 최소한의 보장을 받을 수 있다. 예로 들면 로컬에서 클라이언트는 8000 포트로 서버에서는 2000 포트로 서버를 띄우면 발생한다. 
여기서 출처를 비교하는 로직이 서버에 구현된 것이 아니라 브라우저에 구현되어 있다. 만약 해당 서버가 같은 출처에서 보낸 요청만 받겠다는 
로직을 따로 가지고 있는 경우가 아닌 상태에서, CORS 정책을 위반하는 리소스 요청을 하면 서버는 정상적으로 응답을 하고, 이후 브라우저가 
이 응답을 분석해서 CORS 정책 위반이라고 판단되면 그 응답을 사용하지 않고 버린다. 그래서 브라우저를 통하지 않고 서버 간 통신을 할 때는 
이 정책이 적용되지 않는다. 또한 CORS 정책을 위반하는 리소스 요청 때문에 에러가 발생해도 서버 쪽 로그에는 정상적으로 응답을 했다는 로그만 
남아서, CORS가 돌아가는 방식을 정확히 모르면 에러 트레이싱에 난항을 겪을 수도 있다.
기본적으로 웹 클라이언트가 다른 출처의 리소스를 요청할 때는 HTTP 프로토콜을 사용하여 헤더에 출처(Origin)이라는 필드(Origin: https://www.naver.com)
에 요청을 보내는 출처를 함께 담아보낸다. 이후 서버는 응답 헤더의 Access-Control-Allow-Origin이라는 값에 “이 리소스를 접근하는 것이 허용된 출처”를
내려주고, 응답을 받은 브라우저는 자신이 보냈던 요청의 '출처'와 서버가 보내준 응답의 '접근 허용 출처'을 비교하여 유효 여부를 결정한다.

출처라는 것은 서버주소 문자열 중 프로토콜과 호스트 그리고 포트번호까지 합친 것을 말한다. 예를들면
프로토콜(protocol) :  https://
호스트(host)       :  search.naver.com
포트번호(port)     :  :80
패스(path)         :  /search.naver
쿼리(query)        :  ?where=nexearch&sm=top_hty&fbm=1&ie=utf8&query=%EC%8A%A4%ED%8C%8C%EB%A5%B4%ED%83%80%EC%BD%94%EB%94%A9%ED%81%B4%EB%9F%BD
파편(fragment)     :  #foo
이중 출처는  https://search.naver.com:80 까지이고, 이는 서버를 찾기위한 필수적인 요소이다. 포트번호는 각 웹에서 사용하는 프로토콜의 기본 포트 번호가
정해져 있기 때문에 생략이 가능하다. 하지만 출처에 포트번호가 명시적으로 포합된 경우(https://search.naver.com:525)에는 포트번호까지 일치시켜야 같은
출처라고 인정된다.

CORS는 세가지 시나리오대로 작동하는데 예비요청(Preflight Request), 단순요청(Simple Request), 자격 증명 요청(Credentialed Request)이다.
예비요청(Preflight Request)은 개발할 때 가장 마주치는 시나리오이다. 브라우저는 요청을 한번에 보내지 않고 예비 요청과 본 요청으로 나누어서 전송한다.
예비 요청의 역할은 본 요청을 보내기 전에 브라우저 스스로 이 요청을 보내는 것이 안전한지 확인하는 것이다. 예비 요청에 대한 응답으로 어떤 것들을 금지하고 
있는지에 대한 정보를 응답 헤더에 담아서 보내주게 된다. 이후 브라우저는 자신이 보낸 예비 요청과 서버가 응답에 담아준 허용 정책을 비교하고, 안전하다고 
판단되면 같은 엔드포인트로 다시 본 요청을 보낸다. 그리고 서버가 이 본 요청에 대한 응답을 하면 브라우저는 최종적으로 이 응답 데이터를 자바스크립트에게 넘겨준다.

단순요청(Simple Request)은 서버에게 본 요청부터 보내고, 서버가 이에 대한 응답의 헤더에  '접근 허용 출처' 값을 보내주면 브라우저가 CORS 정책 위반 여부를 
검사하는 방식이다. 즉, 예비요청방식과 단순 요청 시나리오는 전반적인 로직 자체는 같되, 예비 요청의 존재 유무만 다르다. 단순요청을 하기 위해서는 아래의 까다로운
조건들을 만족해야한다. 
- 요청의 메소드는 GET, HEAD, POST 중 하나여야 한다.
- Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width를 제외한 헤더를 사용하면 안된다.
- 만약 Content-Type를 사용하는 경우에는 application/x-www-form-urlencoded, multipart/form-data, text/plain만 허용된다.

자격 증명 요청(Credentialed Request)은 다른 출처 간 통신에서 좀 더 보안을 강화하고 싶을 때 사용하는 방법이다. 브라우저가 제공하는 비동기 리소스 
요청 API인 XMLHttpRequest 객체나 fetch API는 별도의 옵션 없이 브라우저의 쿠키 정보나 인증과 관련된 헤더를 함부로 요청에 담지 않는다. 이때 요청에 
인증과 관련된 정보를 담을 수 있게 해주는 것이 '자격 증명 요청'이다.
- same-origin (기본값)	같은 출처 간 요청에만 인증 정보를 담을 수 있다
- include	모든 요청에 인증 정보를 담을 수 있다
- omit	모든 요청에 인증 정보를 담지 않는다
만약 same-origin이나 include와 같은 옵션을 사용하여 리소스 요청에 '인증 정보'가 포함되면, 이제 브라우저는 다른 출처의 리소스를 요청할 때 
단순히 접근 허용 출처(Access-Control-Allow-Origin)만 확인하는 것이 아니라 다음 검사 조건을 추가하게 된다.
- Access-Control-Allow-Origin에는 *를 사용할 수 없으며, 명시적인 URL이어야한다.
- 응답 헤더에는 반드시 Access-Control-Allow-Credentials: true가 존재해야한다.


이번주는 저번주부터하던 이미지를 s3에 업로드 하고, 게시글에 이미지를 같이 올려서 조회 가능하게 하는 기능과 스케줄러를 통해 오전 1시에 
게시글을 체크하여 댓글이 달리지 않았다면 삭제하는 기능을 만들었다. 먼저 이미지를 게시글에 올리고 조회하는 기능을 만드는 것을 너무 어렵게 
생각하여 많이 해맸다. 또 포스트맨에서 로그인 후 토큰을 넣어주고 무언가 기능을 하는 방법을 몰라 기능이 제대로 굴러가는지 체크하지 못하여 
시간을 많이 날렸다. 또 팀원분과 합치는 과정에서 자료를 다 날릴뻔 했지만 다행히 각 브랜치에서 작업했던 자료를 다시 가져와서 복구할 수 있었다.
하지만 처음부터 팀원 한분이 오시지 않아서 남은 한분과 같이 다 만들어 보려고 했지만, 앞서 말한 것들 때문에 시간이 부족하여 마이페이지 기능은 
만들지 못하고 과제를 마감할 수 밖에 없었다. 
금요일이 되어서는 프론트 분들과 함께 미니 프로젝트를 진행하게 되었다. 미니 프로젝트 내용은 같이 상의해서 정하는 것이었기에 프로젝트 주제는 
소소하게 힐링하고 행복을 느끼는 것들을 사진으로 올리는 게시판을 만드는 것이다. 주요기능은 게시판 작성(이미지 업로드를 s3로), 조회와 로그인, 
회원가입(jwt를 이용) 그리고 댓글과 좋아요 기능이다. 추가로 시간이 남는다면 자동배포와 태그기능도 추가할 생각이다. 하지만 현재 계획한 것들도 
프론트 분들(프론트 2명, 백앤드 3명)이 작업량이 많다고 생각하여 기능을 많이 늘리기는 힘들것 같다. 프론트 분들과 협업은 처음이니 만큼 잘 협력하는
방법을 배워봐야겠다.
