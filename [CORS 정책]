CORS(Cross Origin Resource Sharing)는 직역하면 교차 출처 리소스 공유로 CORS 정책이다. 도메인 및 포트가 다른 서버로 클라이언트가 
요청했을 때 브라우저가 보안상의 이유로 API를 차단하는것이다. CORS라는 방어막이 존재하기 때문에 여러 곳에서 가져오는 리소스가 
안전하다는 최소한의 보장을 받을 수 있다. 예로 들면 로컬에서 클라이언트는 8000 포트로 서버에서는 2000 포트로 서버를 띄우면 발생한다. 
여기서 출처를 비교하는 로직이 서버에 구현된 것이 아니라 브라우저에 구현되어 있다. 만약 해당 서버가 같은 출처에서 보낸 요청만 받겠다는 
로직을 따로 가지고 있는 경우가 아닌 상태에서, CORS 정책을 위반하는 리소스 요청을 하면 서버는 정상적으로 응답을 하고, 이후 브라우저가 
이 응답을 분석해서 CORS 정책 위반이라고 판단되면 그 응답을 사용하지 않고 버린다. 그래서 브라우저를 통하지 않고 서버 간 통신을 할 때는 
이 정책이 적용되지 않는다. 또한 CORS 정책을 위반하는 리소스 요청 때문에 에러가 발생해도 서버 쪽 로그에는 정상적으로 응답을 했다는 로그만 
남아서, CORS가 돌아가는 방식을 정확히 모르면 에러 트레이싱에 난항을 겪을 수도 있다.
기본적으로 웹 클라이언트가 다른 출처의 리소스를 요청할 때는 HTTP 프로토콜을 사용하여 헤더에 출처(Origin)이라는 필드(Origin: https://www.naver.com)
에 요청을 보내는 출처를 함께 담아보낸다. 이후 서버는 응답 헤더의 Access-Control-Allow-Origin이라는 값에 “이 리소스를 접근하는 것이 허용된 출처”를
내려주고, 응답을 받은 브라우저는 자신이 보냈던 요청의 '출처'와 서버가 보내준 응답의 '접근 허용 출처'을 비교하여 유효 여부를 결정한다.

출처라는 것은 서버주소 문자열 중 프로토콜과 호스트 그리고 포트번호까지 합친 것을 말한다. 예를들면
프로토콜(protocol) :  https://
호스트(host)       :  search.naver.com
포트번호(port)     :  :80
패스(path)         :  /search.naver
쿼리(query)        :  ?where=nexearch&sm=top_hty&fbm=1&ie=utf8&query=%EC%8A%A4%ED%8C%8C%EB%A5%B4%ED%83%80%EC%BD%94%EB%94%A9%ED%81%B4%EB%9F%BD
파편(fragment)     :  #foo
이중 출처는  https://search.naver.com:80 까지이고, 이는 서버를 찾기위한 필수적인 요소이다. 포트번호는 각 웹에서 사용하는 프로토콜의 기본 포트 번호가
정해져 있기 때문에 생략이 가능하다. 하지만 출처에 포트번호가 명시적으로 포합된 경우(https://search.naver.com:525)에는 포트번호까지 일치시켜야 같은
출처라고 인정된다.

CORS는 세가지 시나리오대로 작동하는데 예비요청(Preflight Request), 단순요청(Simple Request), 자격 증명 요청(Credentialed Request)이다.
예비요청(Preflight Request)은 개발할 때 가장 마주치는 시나리오이다. 브라우저는 요청을 한번에 보내지 않고 예비 요청과 본 요청으로 나누어서 전송한다.
예비 요청의 역할은 본 요청을 보내기 전에 브라우저 스스로 이 요청을 보내는 것이 안전한지 확인하는 것이다. 예비 요청에 대한 응답으로 어떤 것들을 금지하고 
있는지에 대한 정보를 응답 헤더에 담아서 보내주게 된다. 이후 브라우저는 자신이 보낸 예비 요청과 서버가 응답에 담아준 허용 정책을 비교하고, 안전하다고 
판단되면 같은 엔드포인트로 다시 본 요청을 보낸다. 그리고 서버가 이 본 요청에 대한 응답을 하면 브라우저는 최종적으로 이 응답 데이터를 자바스크립트에게 넘겨준다.

단순요청(Simple Request)은 서버에게 본 요청부터 보내고, 서버가 이에 대한 응답의 헤더에  '접근 허용 출처' 값을 보내주면 브라우저가 CORS 정책 위반 여부를 
검사하는 방식이다. 즉, 예비요청방식과 단순 요청 시나리오는 전반적인 로직 자체는 같되, 예비 요청의 존재 유무만 다르다. 단순요청을 하기 위해서는 아래의 까다로운
조건들을 만족해야한다. 
- 요청의 메소드는 GET, HEAD, POST 중 하나여야 한다.
- Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width를 제외한 헤더를 사용하면 안된다.
- 만약 Content-Type를 사용하는 경우에는 application/x-www-form-urlencoded, multipart/form-data, text/plain만 허용된다.

자격 증명 요청(Credentialed Request)은 다른 출처 간 통신에서 좀 더 보안을 강화하고 싶을 때 사용하는 방법이다. 브라우저가 제공하는 비동기 리소스 
요청 API인 XMLHttpRequest 객체나 fetch API는 별도의 옵션 없이 브라우저의 쿠키 정보나 인증과 관련된 헤더를 함부로 요청에 담지 않는다. 이때 요청에 
인증과 관련된 정보를 담을 수 있게 해주는 것이 '자격 증명 요청'이다.
- same-origin (기본값)	같은 출처 간 요청에만 인증 정보를 담을 수 있다
- include	모든 요청에 인증 정보를 담을 수 있다
- omit	모든 요청에 인증 정보를 담지 않는다
만약 same-origin이나 include와 같은 옵션을 사용하여 리소스 요청에 '인증 정보'가 포함되면, 이제 브라우저는 다른 출처의 리소스를 요청할 때 
단순히 접근 허용 출처(Access-Control-Allow-Origin)만 확인하는 것이 아니라 다음 검사 조건을 추가하게 된다.
- Access-Control-Allow-Origin에는 *를 사용할 수 없으며, 명시적인 URL이어야한다.
- 응답 헤더에는 반드시 Access-Control-Allow-Credentials: true가 존재해야한다.

CORS가 발생하면,
Access to fetch at ‘https://api.lubycon.com/me’ from origin ‘http://localhost:3000’ has been blocked by CORS policy:
No ‘Access-Control-Allow-Origin’ header is present on the requested resource. If an opaque response serves your needs, set the request’s 
mode to ‘no-cors’ to fetch the resource with CORS disabled.
라는 메세지가 출력되어 에러가 난것을 알려준다.


또 다른 리소스 요청 제한 정책으로는 SOP(Same-Origin Policy)가 있다. SOP는 같은 출처에서만 리소스를 공유할 수 있다. 하지만 리소스를 다른 출처에서 
가져오는 일이 매우 흔하기 때문에 몇가지 예외사항을 두는데 그중 하나가 'CORS 정책을 지킨 리소스 요청'이다. 다른 출처로 리소스를 요청하면 SOP 정책을 위반이고, 
추가로 SOP의 예외 조항인 CORS 정책까지 지키지 않는다면 아예 다른 출처의 리소스를 사용할 수 없게 된다.
브라우저의 개발자 도구만 열어도 DOM이 작성이나 통신하는 서버내역, 리소스의 출처와 같은 정보들이 노출되어있다. 때문에 어플리케이션이나 웹 클라이언트는 
사용자의 공격에 매우 취약하기 하다. 어떤 사용자가 소스 코드를 보고 여러 방법을 사용하여 다른 사용자의 클라이언트에서 코드가 실행된 것처럼 만들어 사용자의 
정보를 탈취하기가 너무나도 쉽기 때문에 CORS나 SOP를 이용하는 것이다.
