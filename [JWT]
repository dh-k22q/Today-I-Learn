서버가 1대인 경우 서버에 세션을 만들고 클라이언트의 로그인 정보를 세션에 넣는 방식으로 사용된다. 그러나 점점 사용자가 많아지고 트래픽이 
늘어나면서 트래픽 처리를 위해 서버를 늘리는 경우가 많아졌다. 서버가 늘어나면서 클라이언트와 서버 사이에 이를 분산해서 처리해 줄 수 있는
로드밸런서(Load Balancer)가 생겼다. 하지만 이러한 경우 세션(서버)마다 가지고 있는 로그인 정보가 달라질 수 있다. 그러면 해당 클라이언트 
정보를 가지고 있지 않은 서버에 요청할 경우 로그인이 되지않고 다시 로그인 해야하는 상황이 발생한다. 이를 해결하기 위해 스티키세션(Sticky Session)
을 사용해서 클라이언트마다 요청 서버를 고정하는 방식을 사용했다. 하지만 이러한 방식은 클라이언트마다 한 서버에 묶여있기 때문에 로드밸런서가
균등하게 데이터를 분산하지 못할 수 있고, 클라이언트와 서버를 묶기 위한 또 다른 정보가 필요해진다. 그래서 모든 세션의 정보를 통합해서 저장할 수 
있는 세션 저장소(Session Storage)가 모든 클라이언트 로그인 정보를 가지게 만들어 문제를 해결했다. 이 세션저장소는 어느 세션에서 요청하든 모든 정보를 
조회, 저장, 사용할 수 있게 된다.

JWT는 위와 같은 관리방식 중 하나로 로그인 정보를 서버에 저장하지 않고, 클라이언트에 암호화하여 저장한다. 모든 서버가 동일한 '시크릿 키'를 가지고 
사용한다. 시크릿 키는 로그인 정보를 암호화 시키고 들어온 요청을 위조검증 해준다. JWT는 누구나 복호화가 가능하지만 시크릿키가 없으면 수정하는것이 
불가능하다. JWT인증필터(JWTAuthFilter)를 사용해서 유효성 인증을 실행하는데 이는 모든 api에 대해 확인하기 때문에 예외처리가 필요하다. 예를드면 
로그인페이지, 로그인처리, css파일 등은 인증하지 않아도 접근이 가능해야 하기에 예외처리를 해주어야한다.
JWT의 장점은 접속자가 많을 시 서부 부하를 낮출 수 있다. 또 클라이언트, 서버가 다른 도메인을 사용할 시 CORS문제가 발생할 수 있는 것을 
jwt 토큰을 사용해서 해결할 수 있다. 단점으로는 구현의 복잡도가 높고, JWT에 담는 내용이 커질면 네트워크 비용이 늘어나게 된다. 또 기생성된 
JWT를 일부만 만료할 수가 없고, 시크리키가 유출되면 보안상의 위험이 생길 수 있다.
JWT의 순서는 로그인 시 로그인 정보 JWT로 암호화(시크릿키 사용)한다 - JWT를 클라이언트에 전달한다 - 클라이언트에서 JWT저장(쿠키)한다 - 
클라이언트에서 API요청마다 헤더에 JWT를 포함해서 보낸다 - 서버에서 받은 JWT의 위조여부를 시크릿키로 검증하고, 유효기간이 지나지 않았는지를 
체크한다- 검증 성공하면 JWT를 로그인 정보로 만들어서 사용한다
